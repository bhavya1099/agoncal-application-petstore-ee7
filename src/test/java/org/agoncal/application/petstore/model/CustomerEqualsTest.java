
// ********RoostGPT********
/*
Test generated by RoostGPT for test java-customannotation-test_clone using AI Type  and AI Model

ROOST_METHOD_HASH=equals_20ed3ffb2e
ROOST_METHOD_SIG_HASH=equals_e72790a55e

Scenario 1: Test for Equality with Same Object

Details:
  TestName: testEqualsWithSameObject
  Description: This test is designed to verify the equals method's functionality when the same object is being compared.
Execution:
  Arrange: Create a Customer object and assign it to two different references.
  Act: Invoke the equals method, comparing the two references to the same object.
  Assert: Assert that the equals method returns true.
Validation:
  The equals method should return true when comparing an object with itself. This is a fundamental rule of the equals method and is crucial for maintaining object consistency.

Scenario 2: Test for Equality with Different Object of Same Type

Details:
  TestName: testEqualsWithDifferentObjectOfSameType
  Description: This test is designed to verify the equals method's functionality when different objects of the same type are being compared.
Execution:
  Arrange: Create two different Customer objects with the same login.
  Act: Invoke the equals method, comparing the two different objects.
  Assert: Assert that the equals method returns true.
Validation:
  The equals method in the Customer class is designed to return true when comparing two customers with the same login. This test validates this behavior.

Scenario 3: Test for Equality with Null

Details:
  TestName: testEqualsWithNull
  Description: This test is designed to verify the equals method's functionality when the compared object is null.
Execution:
  Arrange: Create a Customer object.
  Act: Invoke the equals method, comparing the Customer object with null.
  Assert: Assert that the equals method returns false.
Validation:
  The equals method should return false when comparing an object with null. This test verifies this behavior.

Scenario 4: Test for Equality with Different Class Type

Details:
  TestName: testEqualsWithDifferentClassType
  Description: This test is designed to verify the equals method's functionality when the compared object is of a different class type.
Execution:
  Arrange: Create a Customer object and an object of a different class.
  Act: Invoke the equals method, comparing the Customer object with the object of a different class.
  Assert: Assert that the equals method returns false.
Validation:
  The equals method should return false when comparing objects of different class types. This test verifies this behavior.

Scenario 5: Test for Equality with Different Login

Details:
  TestName: testEqualsWithDifferentLogin
  Description: This test is designed to verify the equals method's functionality when the compared objects have different logins.
Execution:
  Arrange: Create two Customer objects with different logins.
  Act: Invoke the equals method, comparing the two objects.
  Assert: Assert that the equals method returns false.
Validation:
  The equals method should return false when comparing two Customer objects with different logins. This test validates this behavior.
*/

// ********RoostGPT********

package org.agoncal.application.petstore.model;

import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.Tag;
import org.agoncal.application.petstore.constraints.Email;
import org.agoncal.application.petstore.constraints.Login;
import javax.persistence.*;
import javax.validation.Valid;
import javax.validation.constraints.NotNull;
import javax.validation.constraints.Past;
import javax.validation.constraints.Size;
import javax.xml.bind.annotation.XmlRootElement;
import java.io.Serializable;
import java.security.MessageDigest;
import java.util.*;
import static org.junit.jupiter.api.Assertions.*;
import org.junit.jupiter.api.*;

public class CustomerEqualsTest {

	@Test
	@Tag("valid")
	public void testEqualsWithSameObject() {
		Customer customer1 = new Customer();
		customer1.setLogin("testLogin");
		Customer customer2 = customer1;

		assertTrue(customer1.equals(customer2),
				"The equals method should return true when comparing an object with itself");
	}

	@Test
	@Tag("valid")
	public void testEqualsWithDifferentObjectOfSameType() {
		Customer customer1 = new Customer();
		customer1.setLogin("testLogin");
		Customer customer2 = new Customer();
		customer2.setLogin("testLogin");

		assertTrue(customer1.equals(customer2),
				"The equals method should return true when comparing two customers with the same login");
	}

	@Test
	@Tag("invalid")
	public void testEqualsWithNull() {
		Customer customer1 = new Customer();
		customer1.setLogin("testLogin");
		assertFalse(customer1.equals(null), "The equals method should return false when comparing an object with null");
	}

	@Test
	@Tag("invalid")
	public void testEqualsWithDifferentClassType() {
		Customer customer1 = new Customer();
		customer1.setLogin("testLogin");
		Object obj = new Object();
		assertFalse(customer1.equals(obj),
				"The equals method should return false when comparing objects of different class types");
	}

	@Test
	@Tag("boundary")
	public void testEqualsWithDifferentLogin() {
		Customer customer1 = new Customer();
		customer1.setLogin("testLogin1");
		Customer customer2 = new Customer();
		customer2.setLogin("testLogin2");
		assertFalse(customer1.equals(customer2),
				"The equals method should return false when comparing two Customer objects with different logins");
	}

}