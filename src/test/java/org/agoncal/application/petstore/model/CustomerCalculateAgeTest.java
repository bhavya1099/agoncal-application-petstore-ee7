
// ********RoostGPT********
/*
Test generated by RoostGPT for test java-customannotation-test_clone using AI Type  and AI Model

ROOST_METHOD_HASH=calculateAge_a25422ac46
ROOST_METHOD_SIG_HASH=calculateAge_eda2a8b4ab

Scenario 1: Test to verify customer age calculation with valid date of birth
  Details:
    TestName: testCalculateAgeWithValidDateOfBirth
    Description: This test is meant to verify the correct calculation of age when a valid date of birth is provided.
  Execution:
    Arrange: Create a customer object and set the date of birth.
    Act: Invoke the calculateAge method.
    Assert: Use JUnit assertions to compare the actual age against the expected age.
  Validation:
    This assertion aims to verify that the age calculation method works correctly with valid dates of birth. The expected result is based on the known age of the customer as per the date of birth set. This test is significant to ensure the proper functioning of the application, as the age of the customer can be a critical factor in certain business scenarios.

Scenario 2: Test to verify customer age calculation with null date of birth
  Details:
    TestName: testCalculateAgeWithNullDateOfBirth
    Description: This test is meant to check the age calculation when the date of birth is null.
  Execution:
    Arrange: Create a customer object without setting the date of birth.
    Act: Invoke the calculateAge method.
    Assert: Use JUnit assertions to check that the age is null.
  Validation:
    This assertion aims to verify that the age calculation handles null dates of birth gracefully, by setting the age to null. This test is significant to ensure the robustness of the application in handling incomplete or missing data.

Scenario 3: Test to verify customer age calculation on their birthday
  Details:
    TestName: testCalculateAgeOnBirthday
    Description: This test is meant to check the age calculation on the day of the customer's birthday.
  Execution:
    Arrange: Create a customer object and set the date of birth to today's date but in a different year.
    Act: Invoke the calculateAge method.
    Assert: Use JUnit assertions to compare the actual age against the expected age.
  Validation:
    This assertion aims to verify that the age calculation correctly increments the age on the day of the customer's birthday. This is based on the standard convention that a person is considered a year older on their birthday. The test is significant to ensure accuracy in age calculation, which can impact business logic related to age-based rules or discounts.

Scenario 4: Test to verify customer age calculation one day before their birthday
  Details:
    TestName: testCalculateAgeOneDayBeforeBirthday
    Description: This test is meant to check the age calculation one day before the customer's birthday.
  Execution:
    Arrange: Create a customer object and set the date of birth to tomorrow's date but in a different year.
    Act: Invoke the calculateAge method.
    Assert: Use JUnit assertions to compare the actual age against the expected age.
  Validation:
    This assertion aims to verify that the age calculation does not prematurely increment the age before the customer's birthday. This is based on the standard convention that a person is considered a year older only on their birthday. The test is significant to ensure accuracy in age calculation, which can impact business logic related to age-based rules or discounts.
*/

// ********RoostGPT********

package org.agoncal.application.petstore.model;

import org.junit.jupiter.api.Tag;
import org.junit.jupiter.api.Test;
import java.util.Calendar;
import java.util.Date;
import java.util.GregorianCalendar;
import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.junit.jupiter.api.Assertions.assertNull;
import org.junit.jupiter.api.*;
import org.agoncal.application.petstore.constraints.Email;
import org.agoncal.application.petstore.constraints.Login;
import javax.persistence.*;
import javax.validation.Valid;
import javax.validation.constraints.NotNull;
import javax.validation.constraints.Past;
import javax.validation.constraints.Size;
import javax.xml.bind.annotation.XmlRootElement;
import java.io.Serializable;
import java.security.MessageDigest;
import java.util.*;

public class CustomerCalculateAgeTest {

	@Test
	@Tag("valid")
	public void testCalculateAgeWithValidDateOfBirth() {
		Customer customer = new Customer();
		Calendar calendar = new GregorianCalendar();
		calendar.set(1990, Calendar.JANUARY, 1);
		customer.setDateOfBirth(calendar.getTime());
		customer.calculateAge();
		int expectedAge = new GregorianCalendar().get(Calendar.YEAR) - 1990;
		assertEquals(expectedAge, customer.getAge());
	}

	@Test
	@Tag("invalid")
	public void testCalculateAgeWithNullDateOfBirth() {
		Customer customer = new Customer();
		customer.setDateOfBirth(null);
		customer.calculateAge();
		assertNull(customer.getAge());
	}

	@Test
	@Tag("boundary")
	public void testCalculateAgeOnBirthday() {
		Customer customer = new Customer();
		Calendar calendar = new GregorianCalendar();
		calendar.set(calendar.get(Calendar.YEAR) - 25, calendar.get(Calendar.MONTH),
				calendar.get(Calendar.DAY_OF_MONTH));
		customer.setDateOfBirth(calendar.getTime());
		customer.calculateAge();
		assertEquals(25, customer.getAge());
	}

	@Test
	@Tag("boundary")
	public void testCalculateAgeOneDayBeforeBirthday() {
		Customer customer = new Customer();
		Calendar calendar = new GregorianCalendar();
		calendar.set(calendar.get(Calendar.YEAR) - 25, calendar.get(Calendar.MONTH),
				calendar.get(Calendar.DAY_OF_MONTH) + 1);
		customer.setDateOfBirth(calendar.getTime());
		customer.calculateAge();
		assertEquals(24, customer.getAge());
	}

}