// ********RoostGPT********
/*
Test generated by RoostGPT for test java-customannotation-test using AI Type  and AI Model

ROOST_METHOD_HASH=calculateAge_a25422ac46
ROOST_METHOD_SIG_HASH=calculateAge_eda2a8b4ab

```
Scenario 1: Customer with a null date of birth

Details:
  TestName: calculateAgeWithNullDateOfBirth
  Description: Tests the calculateAge method when the dateOfBirth attribute is null, to ensure the age remains unset (null).
Execution:
  Arrange: Create a Customer instance and set dateOfBirth to null.
  Act: Invoke the calculateAge method on the Customer instance.
  Assert: Check that the age attribute of the Customer remains null.
Validation:
  The assertion verifies that the age attribute is null when the dateOfBirth is not set, reflecting correct handling of missing birth date data.
  This test is significant as it ensures the method gracefully handles null inputs, a common edge case in data processing.

Scenario 2: Customer born today

Details:
  TestName: calculateAgeBornToday
  Description: Tests the calculateAge method for a customer born on the current date, ensuring the age is calculated as 0.
Execution:
  Arrange: Create a Customer instance and set dateOfBirth to today's date.
  Act: Invoke the calculateAge method on the Customer instance.
  Assert: Check that the age attribute of the Customer is 0.
Validation:
  The assertion checks that the age is calculated correctly as 0 for someone born today.
  This test is important for verifying the boundary condition where the birth date and current date are the same.

Scenario 3: Customer born this year but earlier day

Details:
  TestName: calculateAgeBornEarlierThisYear
  Description: Tests the calculateAge method for a customer born earlier in the current year, ensuring the age is calculated as 0.
Execution:
  Arrange: Create a Customer instance and set the dateOfBirth to a date earlier this year.
  Act: Invoke the calculateAge method on the Customer instance.
  Assert: Check that the age attribute of the Customer is 0.
Validation:
  The assertion ensures the age calculation is correct for a customer born earlier in the same year but has not yet reached their first birthday.
  This test checks the method's accuracy in handling dates within the same year, crucial for correct age computation.

Scenario 4: Customer born last year on the same day

Details:
  TestName: calculateAgeBornLastYearSameDay
  Description: Tests the calculateAge method for a customer born on the same day last year, ensuring the age is calculated as 1.
Execution:
  Arrange: Create a Customer instance and set the dateOfBirth to the same day last year.
  Act: Invoke the calculateAge method on the Customer instance.
  Assert: Check that the age attribute of the Customer is 1.
Validation:
  The assertion verifies that the age is calculated as 1 for someone born on the exact day but the previous year.
  This test is crucial for confirming the method accurately calculates age on anniversaries.

Scenario 5: Customer born last year one day before today

Details:
  TestName: calculateAgeBornLastYearDayBefore
  Description: Tests the calculateAge method for a customer born one day before today's date last year, ensuring the age is calculated as 1.
Execution:
  Arrange: Create a Customer instance and set the dateOfBirth to one day before today, last year.
  Act: Invoke the calculateAge method on the Customer instance.
  Assert: Check that the age attribute of the Customer is 1.
Validation:
  The assertion checks that the age is correctly calculated as 1, as the customer has crossed their birthday this year.
  This test ensures accurate age computation across the boundary of the birthday, which is vital for correct age-related processing.
```
*/

// ********RoostGPT********

package org.agoncal.application.petstore.model;

import org.junit.Test;
import org.junit.experimental.categories.Category;
import java.util.Calendar;
import java.util.Date;
import java.util.GregorianCalendar;
import static org.junit.Assert.*;
import org.agoncal.application.petstore.constraints.Email;
import org.agoncal.application.petstore.constraints.Login;
import javax.persistence.*;
import javax.validation.Valid;
import javax.validation.constraints.NotNull;
import javax.validation.constraints.Past;
import javax.validation.constraints.Size;
import javax.xml.bind.annotation.XmlRootElement;
import java.io.Serializable;
import java.security.MessageDigest;
import java.util.*;

public class CustomerCalculateAgeTest {

	@Test
	@Category(Categories.invalid.class)
	public void calculateAgeWithNullDateOfBirth() {
		Customer customer = new Customer();
		customer.setDateOfBirth(null);
		customer.calculateAge();
		assertNull("Age should be null when date of birth is null", customer.getAge());
	}

	@Test
	@Category(Categories.boundary.class)
	public void calculateAgeBornToday() {
		Customer customer = new Customer();
		customer.setDateOfBirth(new Date());
		customer.calculateAge();
		assertEquals("Age should be 0 if born today", Integer.valueOf(0), customer.getAge());
	}

	@Test
	@Category(Categories.boundary.class)
	public void calculateAgeBornEarlierThisYear() {
		Customer customer = new Customer();
		Calendar earlierThisYear = Calendar.getInstance();
		earlierThisYear.set(Calendar.DAY_OF_YEAR, 1);
		customer.setDateOfBirth(earlierThisYear.getTime());
		customer.calculateAge();
		assertEquals("Age should be 0 if born earlier this year", Integer.valueOf(0), customer.getAge());
	}

	@Test
	@Category(Categories.boundary.class)
	public void calculateAgeBornLastYearSameDay() {
		Customer customer = new Customer();
		Calendar lastYearSameDay = Calendar.getInstance();
		lastYearSameDay.add(Calendar.YEAR, -1);
		customer.setDateOfBirth(lastYearSameDay.getTime());
		customer.calculateAge();
		assertEquals("Age should be 1 if born last year on the same day", Integer.valueOf(1), customer.getAge());
	}

	@Test
	@Category(Categories.boundary.class)
	public void calculateAgeBornLastYearDayBefore() {
		Customer customer = new Customer();
		Calendar lastYearDayBefore = Calendar.getInstance();
		lastYearDayBefore.add(Calendar.YEAR, -1);
		lastYearDayBefore.add(Calendar.DAY_OF_YEAR, -1);
		customer.setDateOfBirth(lastYearDayBefore.getTime());
		customer.calculateAge();
		assertEquals("Age should be 1 if born last year one day before today", Integer.valueOf(1), customer.getAge());
	}

}